<!DOCTYPE html>
<html>
<head>
    <title>Novogodisnja noc</title>
    <script src="libs/three.js"></script>
    <script src="libs/dat.gui.min.js"></script>
    <script src="libs/stats.min.js"></script>
	<script src="../libs/three.js"></script>
    <script src="../libs/RenderPass.js"></script>
            <script src="../libs/CopyShader.js"></script>
            <script src="../libs/ShaderPass.js"></script>
            <script src="../libs/MaskPass.js"></script> 
<script src="../libs/OrbitControls.js"></script>	
<script src="../libs/EffectComposer.js"></script>		
    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<script>

    // global variables
    var renderer;
    var scene;
    var camera;
    var control;
    var stats;
	var cameraControl;
	
	// background
        var cameraBG;
        var sceneBG;
        var composer;
        var clock;

    /**
     * Initializes the scene, camera and objects. Called when the window is
     * loaded by using window.onload (see below)
     */
    function init() {

        // create a scene, that will hold all our elements such as objects, cameras and lights.
        scene = new THREE.Scene();

        // create a camera, which defines where we're looking at.
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

        // create a render, sets the background color and the size
        renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(0x000000, 1.0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMapEnabled = true;
		
	
        // create the ground plane
        var planeGeometry = new THREE.PlaneGeometry(50, 150);
        var planeMaterial = new THREE.MeshPhongMaterial({color: 0xFFFFCC});
        planeMaterial.map = THREE.ImageUtils.loadTexture("assets/textures/snow12.jpg");
		var plane = new THREE.Mesh(planeGeometry, planeMaterial);
        //plane.receiveShadow = true;

        // rotate and position the plane
        plane.rotation.x = -0.5 * Math.PI;
		
        plane.position.x = 20;
        plane.position.y = -5;
        plane.position.z = 0;

        // add the plane to the scene
        scene.add(plane);


        // position and point the camera to the center of the scene
        camera.position.x = 55;
        camera.position.y = 2;
        camera.position.z = 0;
        camera.lookAt(scene.position);

       // add spotlight for the shadows
        var spotLight = new THREE.SpotLight(0xffffff);
        spotLight.position.set(1000, 1000, 1000);
        spotLight.shadowCameraNear = 5;
        spotLight.shadowCameraFar = 5;
        spotLight.castShadow = true;

        scene.add(spotLight);
		
		var coneGeometry = new THREE.CylinderGeometry( 0, 2.5, 8, 45, 30 );// radiusAtTop, radiusAtBottom, height, segmentsAroundRadius, segmentsAlongHeight,
		var coneGeometry1 = new THREE.CylinderGeometry( 0, 2.5, 8, 25, 50 );

//narandzasta jelka
        var pm1 = new THREE.ParticleBasicMaterial();
        pm1.map = THREE.ImageUtils.loadTexture("assets/textures/particles/particle.png");
        pm1.blending= THREE.AdditiveBlending;
        pm1.transparent = true;
        pm1.size=1.0;
        var j1 = new THREE.ParticleSystem(coneGeometry, pm1);
        j1.sortParticles = true;
        j1.name='cone1';
        j1.position.x=19;
		j1.position.y=-1;
		j1.position.z=5;
		
        scene.add(j1);
//svjetlucava crvena
        var pm2 = pm1.clone();
        pm2.map = THREE.ImageUtils.loadTexture("assets/textures/particles/vatromet.jpg");
        var j2 = new THREE.ParticleSystem(coneGeometry, pm2);
        j2.name = 'cone2';
        j2.position.x=20;
		j2.position.y=-1;
		j2.position.z=-3;
		
        scene.add(j2);
//svjetlucava crvena		
		var pm3 = new THREE.ParticleBasicMaterial();
        pm3.map= THREE.ImageUtils.loadTexture("assets/textures/particles/vatromet.jpg");
        pm3.blending= THREE.AdditiveBlending;
        pm3.transparent = true;
        pm3.size=1.0;
        var j3 = new THREE.ParticleSystem(coneGeometry1, pm3);
        j3.sortParticles = true;
        j3.name='cone3';
        j3.position.x=33;
		j3.position.y=-1;
		j3.position.z=5;
		//j1.position.y=5;
        scene.add(j3);
//zelena jelka
        var pm4 = pm3.clone();
        pm4.map = THREE.ImageUtils.loadTexture("assets/textures/particles/particle2.png");
        var j4 = new THREE.ParticleSystem(coneGeometry1, pm4);
        j4.name = 'cone4';
        j4.position.x=36;
		j4.position.y=-2;
		j4.position.z=0;
        scene.add(j4);
//luubicasta jelka	
		var pm5 = pm3.clone();
        pm5.map = THREE.ImageUtils.loadTexture("assets/textures/particles/vatromet2.jpg");
        var j5 = new THREE.ParticleSystem(coneGeometry1, pm5);
        j5.name = 'cone5';
        j5.position.x=0;//34,-2,-18
		j5.position.y=-1;
		j5.position.z=5;
        scene.add(j5);

		
		cameraControl = new THREE.OrbitControls(camera);

        // setup the control object for the control gui
        control = new function() {
            this.rotationSpeed = 0.001;
            this.opacity = 0.6;
			
         
        };

        // add extras
        addControlGui(control);
        addStatsObject();

		// add background using a camera
            cameraBG = new THREE.OrthographicCamera(-window.innerWidth, window.innerWidth, window.innerHeight, -window.innerHeight, -10000, 10000);
            cameraBG.position.z = 50;
            sceneBG = new THREE.Scene();

            var materialColor = new THREE.MeshBasicMaterial({ map: THREE.ImageUtils.loadTexture("assets/textures/snow101.jpg"), depthTest: false });
            var bgPlane = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), materialColor);
            bgPlane.position.z = -100;
            bgPlane.scale.set(window.innerWidth * 2, window.innerHeight * 2, 1);
            sceneBG.add(bgPlane);

            // setup the composer steps
            // first render the background
            var bgPass = new THREE.RenderPass(sceneBG, cameraBG);
            // next render the scene (rotating earth), without clearing the current output
            var renderPass = new THREE.RenderPass(scene, camera);
            renderPass.clear = false;
            // finally copy the result to the screen
            var effectCopy = new THREE.ShaderPass(THREE.CopyShader);
            effectCopy.renderToScreen = true;

            // add these passes to the composer
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(bgPass);
            composer.addPass(renderPass);
            composer.addPass(effectCopy);

        // add the output of the renderer to the html element
        document.body.appendChild(renderer.domElement);

        console.log('Log statement from the init function');



        // call the render function, after the first render, interval is determined
        // by requestAnimationFrame
        setupSound();
        render();


        loadSound("assets/audio/merry_christmas.wav");

    }


    function addControlGui(controlObject) {
       // var gui = new dat.GUI();
        //gui.add(controlObject, 'rotationSpeed', -0.01, 0.01);
		//gui.addColor(controlObject, 'ambientLightColor');
        //    gui.addColor(controlObject, 'directionalLightColor');
    }

    function addStatsObject() {
        stats = new Stats();
        stats.setMode(0);

        stats.domElement.style.position = 'absolute';
        stats.domElement.style.left = '0px';
        stats.domElement.style.top = '0px';

        document.body.appendChild( stats.domElement );
    }

    var context;
    var sourceNode;
    var analyser;
    var analyser2;

    /**
     * Called when the scene needs to be rendered. Delegates to requestAnimationFrame
     * for future renders
     */
    function render() {

        // update stats
        stats.update();
		cameraControl.update();

        // and render the scene
        renderer.render(scene, camera);
		
        updateCones();
		renderer.autoClear = false;
        composer.render();

        // render using requestAnimationFrame
        requestAnimationFrame(render);
    }

    function updateCones() {
        // get the average for the first channel
        var array =  new Uint8Array(analyser.frequencyBinCount);
        analyser.getByteFrequencyData(array);
        var average = getAverageVolume(array);

        // get the average for the second channel
        var array2 =  new Uint8Array(analyser2.frequencyBinCount);
        analyser2.getByteFrequencyData(array2);
        var average2 = getAverageVolume(array2);

        // clear the current state
        if (scene.getObjectByName('cone1')) {
            var cone1 = scene.getObjectByName('cone1');
            var cone2 = scene.getObjectByName('cone2');
			var cone3 = scene.getObjectByName('cone3');
            var cone4 = scene.getObjectByName('cone4');
			var cone5 = scene.getObjectByName('cone5');
            cone1.scale.y=average/20;
            cone2.scale.y=average2/20;
			cone3.scale.y=average/20;
            cone4.scale.y=average2/20;
			cone5.scale.y=average/20;

        }
    }



    function setupSound() {
        if (! window.AudioContext) {
            if (! window.webkitAudioContext) {
                alert('no audiocontext found');
            }
            window.AudioContext = window.webkitAudioContext;
        }
        context = new AudioContext();

        // setup a analyzer
        analyser = context.createAnalyser();
        analyser.smoothingTimeConstant = 0.4;
        analyser.fftSize = 1024;

        analyser2 = context.createAnalyser();
        analyser2.smoothingTimeConstant = 0.4;
        analyser2.fftSize = 1024;

        // create a buffer source node
        sourceNode = context.createBufferSource();
        var splitter = context.createChannelSplitter();

        // connect the source to the analyser and the splitter
        sourceNode.connect(splitter);

        // connect one of the outputs from the splitter to
        // the analyser
        splitter.connect(analyser,0);
        splitter.connect(analyser2,1);

        // and connect to destination
        sourceNode.connect(context.destination);

        context = new AudioContext();
    }


    function getAverageVolume(array) {
        var values = 0;
        var average;

        var length = array.length;

        // get all the frequency amplitudes
        for (var i = 0; i < length; i++) {
            values += array[i];
        }

        average = values / length;
        return average;
    }

    function playSound(buffer) {
        sourceNode.buffer = buffer;
        sourceNode.start(0);
    }

    // load the specified sound
    function loadSound(url) {
        var request = new XMLHttpRequest();
        request.open('GET', url, true);
        request.responseType = 'arraybuffer';

        // When loaded decode the data
        request.onload = function() {

            // decode the data
            context.decodeAudioData(request.response, function(buffer) {
                // when the audio is decoded play the sound
                playSound(buffer);
            }, onError);
        }
        request.send();
    }

    function onError(e) {
        console.log(e);
    }


    /**
     * Function handles the resize event. This make sure the camera and the renderer
     * are updated at the correct moment.
     */
    function handleResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // calls the init function when the window is done loading.
    window.onload = init;
    // calls the handleResize function when the window is resized
    window.addEventListener('resize', handleResize, false);

</script>
<body>
</body>
</html>